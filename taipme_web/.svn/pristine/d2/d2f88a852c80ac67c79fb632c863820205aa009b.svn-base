/*
 * Created on 13 lug 2017 ( Time 12:07:28 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package org.whitepaper.business.service.impl.custom;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.whitepaper.bean.Messaggio;
import org.whitepaper.bean.MessaggioTags;
import org.whitepaper.bean.jpa.MessaggioEntity;
import org.whitepaper.business.service.MessaggioService;
import org.whitepaper.business.service.MessaggioTagsService;
import org.whitepaper.business.service.custom.MessaggioCustomService;
import org.whitepaper.business.service.custom.MessaggioSegnalatoCustomService;
import org.whitepaper.business.service.custom.MessaggioTagCustomService;
import org.whitepaper.business.service.custom.UtenteActionCustomService;
import org.whitepaper.business.service.mapping.MessaggioServiceMapper;
import org.whitepaper.business.service.mapping.MessaggioTagsServiceMapper;
import org.whitepaper.data.repository.jpa.MessaggioJpaRepository;
import org.whitepaper.data.repository.jpa.custom.AggregateMsgPerCatEntity;
import org.whitepaper.data.repository.jpa.custom.AggregateMsgPerDatPub;
import org.whitepaper.data.repository.jpa.custom.MessaggioCustomJpaRepository;
import org.whitepaper.utility.ConstantsDefinition;
import org.whitepaper.utility.UtilityFunction;

/**
 * Implementation of AnaUtenteService
 */
@Component
@Transactional(rollbackFor = Exception.class)
public class MessaggioCustomServiceImpl implements MessaggioCustomService {

	private static Logger logger = LoggerFactory.getLogger(MessaggioCustomServiceImpl.class);

	@Resource
	private MessaggioService messaggioService;

	@Resource
	private MessaggioSegnalatoCustomService messaggioSegnalatoCustomService;
	
	@Resource
	private MessaggioJpaRepository messaggioJpaRepository;
	
	@Resource
	private MessaggioTagsService messaggioTagsService;
	
	@Resource
	private MessaggioTagsServiceMapper messaggioTagsServiceMapper;

	@Resource
	private MessaggioTagCustomService messaggioTagCustomService;
	
	@Resource
	private MessaggioCustomJpaRepository messaggioCustomJpaRepository;
	
	@Resource
	private MessaggioServiceMapper messaggioServiceMapper;
	
	@Resource
	UtenteActionCustomService utenteActionCustomService;
	
	//lettura casuale di un messaggio senza risposta (diverso da autore se stesso) 
	public Messaggio findMsgRandomNoReplyAutoreDiverso(Integer idUteAut, String codTipMsg) {
		
		Messaggio msgRandom = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByNotIdAutoreAndCodTipMsgAndReplyNull(idUteAut, codTipMsg);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return msgRandom;
			
			//lettura casuale messaggio
			int numMsg = listMsgEnt.size();
			Random rand = new Random();
			MessaggioEntity msgEntityRandom = listMsgEnt.get(rand.nextInt(numMsg));
			
			//primo della lista di messaggi random
			//MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				msgRandom = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgRandomNoReplyAutoreDiverso: errore: " + ex.getMessage() );
		}		
		
		return msgRandom;
	}
	
	//lettura messaggio per autore e foglio
	public Messaggio findMsgByAutoreAndIdFoglio(Integer idUteAut, Integer idFoglio) {
		
		Messaggio messaggio = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByIdAutoreAndIdFoglio(idUteAut, idFoglio);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return messaggio;
			
			MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgByAutoreAndIdFoglio: errore: " + ex.getMessage() );
		}		
		
		return messaggio;
	}
	
	//lettura messaggio per conversazione PRIVATA
	public Messaggio findMsgPerConversazionePrivata(Integer idMsg, Integer idUteAut, Integer idUteReply, Integer idMsgReply) {			
		
		Messaggio msg = null;
		if ( null==idMsg )
			return msg;
		
		try {			
			String codTipMsg = ConstantsDefinition.CODMSG_PRI;
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findMsgPerConversazione(idMsg, idUteAut, idUteReply, codTipMsg, idMsgReply);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return msg;
			
			//TODO leggo messaggio a caso
			MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				msg = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgPerConversazione: errore: " + ex.getMessage() );
		}		
		
		return msg;
	}
		
	//inserimento nuovo messaggio e relativi tags (se isSaveTags Ã¨ true)
	@Override
	public Messaggio insertMsgAndTags(Integer idUteAut, Integer idUteReply, String desMsg, String codTipMsg, Integer idFoglio, Integer idMsgReply, boolean isSaveTags) {
		
		Messaggio messaggioCreated = null;
		try {
			
			//no tags html (lascia solo br)
			String desMsgNoHtml = UtilityFunction.noHtmlWithBr(desMsg);
			
			//inserimento messaggio
			Messaggio messaggio = new Messaggio();
			messaggio.setIdUteAut(idUteAut);
			messaggio.setIdUteReply(idUteReply);
			messaggio.setIdMsgReply(idMsgReply);
			messaggio.setDesMsg(desMsgNoHtml);
			messaggio.setCodTipMsg(codTipMsg);	
			messaggio.setIdFoglio(idFoglio);
			messaggio.setDatUltMov( Calendar.getInstance().getTime() );
			
			//data orario PRIMA pubblicazione messaggio
			if ( null==messaggio.getDataPub() ) 							
				messaggio.setDataPub( Calendar.getInstance().getTime() );
						
			messaggioCreated = messaggioService.create(messaggio);	
			if ( null!=messaggioCreated && isSaveTags) {
				//inserimento tags
				saveTags(messaggioCreated.getIdMsg(), codTipMsg, desMsgNoHtml);
			}
			
			//incrementa numero di risposte salvate per giornata (statistica)
			utenteActionCustomService.saveNumActionPerIdUteAndData(idUteAut, ConstantsDefinition.COD_TIP_OPERAZ_REPLY, new Date());
			
		} catch (Exception ex) {
			logger.error("******insertMsg: errore: " + ex.getMessage() );
		}	
		return messaggioCreated;
	}
	 
	//tags salvati solo per messaggi PUBBLICI
	private void saveTags(Integer idMsg, String codTipMsg, String desMsg) {
		
		if ( UtilityFunction.isFieldBlank(codTipMsg) || !codTipMsg.equalsIgnoreCase(ConstantsDefinition.CODMSG_PUB) )
			return;
		
		if ( UtilityFunction.isFieldBlank(desMsg) )
			return;
		
		//replace newline spazio
		desMsg = desMsg.replace("\n", " ");
		
		//split messaggio per tags
		String[] arrTags = desMsg.split(" ");
		if ( null==arrTags || 0==arrTags.length )
			return;
		
		//save lista tags
		for (int i = 0; i < arrTags.length; i++) {
			
			String tag = arrTags[i];
			if ( UtilityFunction.isFieldBlank(tag) )
				continue;
			
			boolean isHshTag = tag.contains("#");
			if ( !isHshTag )
				continue;
			
			//save tag
			tag = tag.substring(1, tag.length()).trim().toLowerCase();
			if ( tag.length()>50 )
				tag = tag.substring(0, 50);
			
			MessaggioTags msgTag = new MessaggioTags();
			msgTag.setIdMsg(idMsg);
			msgTag.setTag(tag);
			messaggioTagsService.create(msgTag);
			
		}//endofr		
	}
	
	
	//inserimento messaggio di risposta e aggiornamento stato
	@Override
	public Messaggio insertReplyMsg(Integer idMsg, Integer idAut, Integer idUteReply, String desMsg, Integer idFoglio) {
		Messaggio msgNew = null;
		MessaggioEntity messaggioEntitySaved = null;
		try {
			
			//load messaggio iniziale
			Messaggio msgIniziale = messaggioService.findById(idMsg);
			if ( null==msgIniziale )
				return null;
						
			if ( msgIniziale.getIdUteAut().intValue()!=idAut.intValue() ) {
				//errore				
				return null;
			}
			
			//////////////////////////////////////////////////////////////////////////
			//la prima risposta, inserisco messaggio REPLY
			//le volte successive, aggiorna descrizione della rispota utente corrente
			//////////////////////////////////////////////////////////////////////////			
			if ( null==msgIniziale.getIdMsgReply() ) {
						
				//inserimentor messaggio risposta (privata) con idMsgReply = idMsg iniziale (no save tags)			
				msgNew = insertMsgAndTags(idUteReply, idAut, desMsg, ConstantsDefinition.CODMSG_PRI, idFoglio, idMsg, false);
				
				//aggiornamento messaggio originale con info messaggio REPLY												
				msgIniziale.setIdUteReply(msgNew.getIdUteAut());
				msgIniziale.setIdMsgReply(msgNew.getIdMsg());
				msgIniziale.setCodTipMsg(ConstantsDefinition.CODMSG_PRI);
				MessaggioEntity messaggioEntity = new MessaggioEntity();
				messaggioServiceMapper.mapMessaggioToMessaggioEntity(msgIniziale, messaggioEntity);
				messaggioEntitySaved = messaggioJpaRepository.save(messaggioEntity);				
				
			} else {

				//pulizia tag html (no br)
				String desMsgNoHtml = UtilityFunction.noHtmlWithBr(desMsg);
				
				//aggiornamento descrizione (risposta) messaggio REPLY e STATO da LETTO a PRIVATO
				Messaggio msgReply = messaggioService.findById(msgIniziale.getIdMsgReply());
				msgReply.setDatUltMov( Calendar.getInstance().getTime() );								
				msgReply.setDesMsg(desMsgNoHtml);
				msgReply.setCodTipMsg(ConstantsDefinition.CODMSG_PRI);
				MessaggioEntity messaggioEntityReply = new MessaggioEntity();
				messaggioServiceMapper.mapMessaggioToMessaggioEntity(msgReply, messaggioEntityReply);
				messaggioEntitySaved = messaggioJpaRepository.save(messaggioEntityReply);
				
				//incrementa numero di risposte salvate per giornata (statistica)
				utenteActionCustomService.saveNumActionPerIdUteAndData(idUteReply, ConstantsDefinition.COD_TIP_OPERAZ_REPLY, new Date());
			}
			
			//cancellazione tags del messaggio originale e risposta (ora sono messaggi PRIVATI)
			messaggioTagCustomService.deleteTagsPerIdMsg(idMsg);
			
						                            					
		} catch (Exception ex) {
			logger.error("******insertReplyMsg: errore: " + ex.getMessage() );
		}	
		if ( null!=messaggioEntitySaved)
			msgNew = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntitySaved);
		
		return msgNew;
	}

	//conta numero messaggi di autori diversi e senza risposta
	public int countNumMessaggiAutDiversiPerTipoNoReply(Integer idUte, String codTipMsg) {
		
		int numMsg = 0;	
		try {			
			Integer intNumMsg = messaggioCustomJpaRepository.countNumMsgNotIdAutoreAndCodTipMsgAndReplyNull(idUte, codTipMsg);
			if ( null!=intNumMsg )
				numMsg = intNumMsg.intValue();
			
		} catch (Exception ex) {
			logger.error("******countNumMessaggiPerTipo: errore: " + ex.getMessage() );
		}		
		
		return numMsg;
	}

	
	//conta numero messaggi per autore
	public int countMsgByIdAutore(Integer idUteAut) {
		
		int numMsg = 0;	
		try {			
			Long intNumMsg = messaggioCustomJpaRepository.countMsgByIdAutore(idUteAut);
			if ( null!=intNumMsg )
				numMsg = intNumMsg.intValue();
			
		} catch (Exception ex) {
			logger.error("******countMsgByIdAutore: errore: " + ex.getMessage() );
		}		
		
		return numMsg;
	}
	
	//strappo messaggio
	@Override
	public boolean strappoMsg(Integer idUte, Integer idMsg, Integer idMsgReply) {
		boolean isError = false;
		try {

			//cancella eventuale risposta e relativi tags
			if ( null!=idMsgReply ) {
				//cancella tags /messaggio segnalato / messaggio originale
				deleteMsgTransaction(idMsgReply);
				
				//incrementa numero di strappi giornalieri solo per CONVERSAZIONE
				utenteActionCustomService.saveNumActionPerIdUteAndData(idUte, ConstantsDefinition.COD_TIP_OPERAZ_STRAPPA, new Date());			
			}

			//cancella tags /messaggio segnalato / messaggio originale
			deleteMsgTransaction(idMsg);			
		
		} catch (Exception ex) {
			logger.error("******strappoMsg: errore: " + ex.getMessage() );
			isError = true;
		}	
		return isError;
	}
	
	
	
	private void deleteMsgTransaction(Integer idMsg) {
		//cancella tags messaggio originale
		messaggioTagCustomService.deleteTagsPerIdMsg(idMsg);
		
		//cancella messaggio segnalato
		messaggioSegnalatoCustomService.deleteMsgPerIdMsg(idMsg);

		//cancella messaggio
		messaggioService.delete(idMsg);
	}

	//aggiornamento codice tipo messaggio e lettura messaggio REPLY
	@Override
	public Messaggio updateCodTipMsgAndFindMsgReply(Integer idMsg, String codTipMsg) {
				
		Messaggio msgOut = null;
		try {
			
			//load messaggio
			Messaggio messaggio = messaggioService.findById(idMsg);
			if ( null==messaggio )
				return msgOut;
						
			//aggiornamento messaggio LETTO			
			messaggio.setCodTipMsg(codTipMsg);
			messaggio.setDatUltMov( Calendar.getInstance().getTime() );												
			MessaggioEntity messaggioEntity = new MessaggioEntity();
			messaggioServiceMapper.mapMessaggioToMessaggioEntity(messaggio, messaggioEntity);
			MessaggioEntity	messaggioEntitySaved = messaggioJpaRepository.save(messaggioEntity);
			
			msgOut = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntitySaved);			                      					
		} catch (Exception ex) {
			logger.error("******updateCodTipMsgAndFindMsgReply: errore: " + ex.getMessage() );			
		}	
		
		return msgOut;
	}
	
	//lettura messaggio per idMsg e foglio
	public Messaggio findMsgByIdMsgAndIdFoglio(Integer idMsg, Integer idFoglio) {
		
		Messaggio messaggio = null;	
		try {			
			MessaggioEntity msgEnt = messaggioCustomJpaRepository.findByIdMsgAndIdFoglio(idMsg, idFoglio);	
			if ( null==msgEnt )
				return messaggio;
			
			//conversione
			messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEnt);
			
		} catch (Exception ex) {
			logger.error("******findMsgByIdMsgAndIdFoglio: errore: " + ex.getMessage() );
		}		
		
		return messaggio;
	}

	//conta numero di fogli utilizzati dall'utente
	public int countNumFogliUtilizzati(Integer idUte) {
		
		int numFogli = 0;	
		try {			
			Integer intNumFogli = messaggioCustomJpaRepository.countNumFogliUtilizzati(idUte);
			if ( null!=intNumFogli )
				numFogli = intNumFogli.intValue();
			
		} catch (Exception ex) {
			logger.error("******countNumFogliUtilizzati: errore: " + ex.getMessage() );
		}		
		
		return numFogli;
	}
	
	//lettura di tutti i messaggi per autore 	
	public List<Messaggio> findMsgByAutore(Integer idUteAut) {
		
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByIdAutore(idUteAut);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				
				//check se messaggio presenta risposta
				boolean	isPresenteRisposta = false;
			  
				//per messaggio privato, lettura messaggio originale
				String codTipMsg = messaggio.getCodTipMsg();		
				if ( null!=codTipMsg && codTipMsg.equals(ConstantsDefinition.CODMSG_PRI )) {
					
					//lettura risposta PRIVATA
					Messaggio msgRisposta = findMsgPerConversazionePrivata(messaggio.getIdMsgReply()
																		 , messaggio.getIdUteReply()
																		 , messaggio.getIdUteAut()																						 
																		 , messaggio.getIdMsg());					
					//se risposta successiva a messaggio originale NO REPLY			
					if ( null!=msgRisposta && msgRisposta.getDatUltMov().compareTo(messaggio.getDatUltMov())>0 )	{						
						isPresenteRisposta = true;					
					}			

				}//endif codTipMsg									
				
				messaggio.setPresenteRisposta(isPresenteRisposta);
				
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgByAutore: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}

	public List<AggregateMsgPerCatEntity> countNumMsgPerTipo() {

		List<AggregateMsgPerCatEntity> listMsgPerTipo = null;	
		try {			
			listMsgPerTipo = messaggioCustomJpaRepository.countNumMsgPerTipo();
			
		} catch (Exception ex) {
			logger.error("******countNumMsgPerTipo: errore: " + ex.getMessage() );
		}		
		
		return listMsgPerTipo;
	}
	
	//ricerca dei messaggi per hashtag e diversi da autore corrente 	
	public List<Messaggio> findMsgPubByHashTagAndNotAutore(String hashtag, Integer idUteAut) {
		
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findMsgPubByHashTagAndNotAutore(hashtag, idUteAut);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgPubByHashTagAndNotAutore: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}
	
	//lettura messaggi per tipo messaggi
	public List<Messaggio> findMsgPerCodTipMsg(String codTipMsg) {
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByCodTipMsg(codTipMsg);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgPerCodTipMsg: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}
	
	//conta numero di messaggi NUOVI pubblicati per DATA PUB
	public List<AggregateMsgPerDatPub> countMsgPerDataPubAfterDataInput(Date dataIn) {
		
		List<AggregateMsgPerDatPub> listNumMsg = null;	
		try {			
			listNumMsg = messaggioCustomJpaRepository.countMsgPerDataPubAfterDataInput(dataIn);
			
			
		} catch (Exception ex) {
			logger.error("******countMsgPerDataInput: errore: " + ex.getMessage() );
		}		
		
		return listNumMsg;
	}

}
