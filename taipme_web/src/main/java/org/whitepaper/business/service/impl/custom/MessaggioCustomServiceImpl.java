/*
 * Created on 13 lug 2017 ( Time 12:07:28 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package org.whitepaper.business.service.impl.custom;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Random;

import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.whitepaper.bean.Messaggio;
import org.whitepaper.bean.MessaggioTags;
import org.whitepaper.bean.jpa.MessaggioEntity;
import org.whitepaper.business.service.MessaggioService;
import org.whitepaper.business.service.MessaggioTagsService;
import org.whitepaper.business.service.custom.MessaggioCustomService;
import org.whitepaper.business.service.custom.MessaggioSegnalatoCustomService;
import org.whitepaper.business.service.custom.MessaggioTagCustomService;
import org.whitepaper.business.service.custom.UtenteActionCustomService;
import org.whitepaper.business.service.mapping.MessaggioServiceMapper;
import org.whitepaper.business.service.mapping.MessaggioTagsServiceMapper;
import org.whitepaper.data.repository.jpa.MessaggioJpaRepository;
import org.whitepaper.data.repository.jpa.custom.AggregateMsgPerCatEntity;
import org.whitepaper.data.repository.jpa.custom.AggregateMsgPerDatPub;
import org.whitepaper.data.repository.jpa.custom.MessaggioCustomJpaRepository;
import org.whitepaper.utility.ConstantsDefinition;
import org.whitepaper.utility.UtilityFunction;

/**
 * Implementation of AnaUtenteService
 */
@Component
@Transactional(rollbackFor = Exception.class)
public class MessaggioCustomServiceImpl implements MessaggioCustomService {

	private static Logger logger = LoggerFactory.getLogger(MessaggioCustomServiceImpl.class);

	@Resource
	private MessaggioService messaggioService;

	@Resource
	private MessaggioSegnalatoCustomService messaggioSegnalatoCustomService;
	
	@Resource
	private MessaggioJpaRepository messaggioJpaRepository;
	
	@Resource
	private MessaggioTagsService messaggioTagsService;
	
	@Resource
	private MessaggioTagsServiceMapper messaggioTagsServiceMapper;

	@Resource
	private MessaggioTagCustomService messaggioTagCustomService;
	
	@Resource
	private MessaggioCustomJpaRepository messaggioCustomJpaRepository;
	
	@Resource
	private MessaggioServiceMapper messaggioServiceMapper;
	
	@Resource
	UtenteActionCustomService utenteActionCustomService;
	
	//lettura casuale di un messaggio senza risposta (diverso da autore se stesso) 
	public Messaggio findMsgRandomNoReplyAutoreDiverso(Integer idUteAut, String codTipMsg) {
		
		Messaggio msgRandom = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByNotIdAutoreAndCodTipMsgAndReplyNull(idUteAut, codTipMsg);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return msgRandom;
			
			//lettura casuale messaggio
			int numMsg = listMsgEnt.size();
			Random rand = new Random();
			MessaggioEntity msgEntityRandom = listMsgEnt.get(rand.nextInt(numMsg));
			
			//primo della lista di messaggi random
			//MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				msgRandom = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgRandomNoReplyAutoreDiverso: errore: " + ex.getMessage() );
		}		
		
		return msgRandom;
	}
	
	//lettura messaggio per autore e foglio
	public Messaggio findMsgByAutoreAndIdFoglio(Integer idUteAut, Integer idFoglio) {
		
		Messaggio messaggio = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByIdAutoreAndIdFoglio(idUteAut, idFoglio);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return messaggio;
			
			MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgByAutoreAndIdFoglio: errore: " + ex.getMessage() );
		}		
		
		return messaggio;
	}
	
	//lettura messaggio per conversazione PRIVATA
	public Messaggio findMsgPerConversazionePrivata(Integer idMsg, Integer idUteAut, Integer idUteReply, Integer idMsgReply) {			
		
		Messaggio msg = null;
		if ( null==idMsg )
			return msg;
		
		try {			
			String codTipMsg = ConstantsDefinition.CODMSG_PRI;
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findMsgPerConversazione(idMsg, idUteAut, idUteReply, codTipMsg, idMsgReply);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return msg;
			
			//TODO leggo messaggio a caso
			MessaggioEntity msgEntityRandom = listMsgEnt.get(0);
			if ( null!=msgEntityRandom )
				msg = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEntityRandom);
			
		} catch (Exception ex) {
			logger.error("******findMsgPerConversazione: errore: " + ex.getMessage() );
		}		
		
		return msg;
	}
		
	//inserimento nuovo messaggio e relativi tags (se isSaveTags Ã¨ true)
	@Override
	public Messaggio insertMsgAndTags(Integer idUteAut, Integer idUteReply, String desMsg, String codTipMsg, Integer idFoglio, Integer idMsgReply, boolean isSaveTags) {
		
		Messaggio messaggioCreated = null;
		try {
			
			//no tags html (lascia solo br)
			String desMsgNoHtml = UtilityFunction.noHtmlWithBr(desMsg);
			
			//inserimento messaggio
			Messaggio messaggio = new Messaggio();
			messaggio.setIdUteAut(idUteAut);
			messaggio.setIdUteReply(idUteReply);
			messaggio.setIdMsgReply(idMsgReply);
			messaggio.setDesMsg(desMsgNoHtml);
			messaggio.setCodTipMsg(codTipMsg);	
			messaggio.setIdFoglio(idFoglio);
			messaggio.setDatUltMov( Calendar.getInstance().getTime() );
			
			//data orario PRIMA pubblicazione messaggio
			if ( null==messaggio.getDataPub() ) 							
				messaggio.setDataPub( Calendar.getInstance().getTime() );
						
			messaggioCreated = messaggioService.create(messaggio);	
			if ( null!=messaggioCreated && isSaveTags) {
				//inserimento tags
				saveTags(messaggioCreated.getIdMsg(), codTipMsg, desMsgNoHtml);
			}
			
			//incrementa numero di risposte salvate per giornata (statistica)
			utenteActionCustomService.saveNumActionPerIdUteAndData(idUteAut, ConstantsDefinition.COD_TIP_OPERAZ_REPLY, new Date());
			
		} catch (Exception ex) {
			logger.error("******insertMsg: errore: " + ex.getMessage() );
		}	
		return messaggioCreated;
	}
	 
	//tags salvati solo per messaggi PUBBLICI
	private void saveTags(Integer idMsg, String codTipMsg, String desMsg) {
		
		if ( UtilityFunction.isFieldBlank(codTipMsg) || !codTipMsg.equalsIgnoreCase(ConstantsDefinition.CODMSG_PUB) )
			return;
		
		if ( UtilityFunction.isFieldBlank(desMsg) )
			return;
		
		//replace newline spazio
		desMsg = desMsg.replace("\n", " ");
		
		//split messaggio per tags
		String[] arrTags = desMsg.split(" ");
		if ( null==arrTags || 0==arrTags.length )
			return;
		
		//save lista tags
		for (int i = 0; i < arrTags.length; i++) {
			
			String tag = arrTags[i];
			if ( UtilityFunction.isFieldBlank(tag) )
				continue;
			
			boolean isHshTag = tag.contains("#");
			if ( !isHshTag )
				continue;
			
			//save tag
			tag = tag.substring(1, tag.length()).trim().toLowerCase();
			if ( tag.length()>50 )
				tag = tag.substring(0, 50);
			
			MessaggioTags msgTag = new MessaggioTags();
			msgTag.setIdMsg(idMsg);
			msgTag.setTag(tag);
			messaggioTagsService.create(msgTag);
			
		}//endofr		
	}
	
	
	//inserimento messaggio di risposta e aggiornamento stato
    @Override
    public Messaggio insertReplyMsg(Integer idMsgOriginale, Integer idUteAutOriginale, Integer idUteReplier, String desMsgReply, Integer idFoglio) {
        Messaggio newlySentOrUpdatedMessage = null;
        
        try {
            // Load the message being replied to (M_Other)
            Messaggio mOther = messaggioService.findById(idMsgOriginale);

            if (mOther == null) {
                logger.error("******insertReplyMsg: Original message (ID: {}) not found.", idMsgOriginale);
                return null;
            }

            // Validate that idUteAutOriginale matches the author of mOther
            if (mOther.getIdUteAut() == null || !mOther.getIdUteAut().equals(idUteAutOriginale)) {
                logger.error("******insertReplyMsg: Author mismatch for original message (ID: {}). Expected: {}, Found: {}", idMsgOriginale, idUteAutOriginale, mOther.getIdUteAut());
                return null; 
            }

            String desMsgNoHtml = UtilityFunction.noHtmlWithBr(desMsgReply);

            // Scenario 1: First reply to a public message (mOther.idMsgReply is null)
            // This creates the initial private pair.
            if (mOther.getIdMsgReply() == null && ConstantsDefinition.CODMSG_PUB.equals(mOther.getCodTipMsg())) {
                logger.debug("insertReplyMsg: First reply to public message ID {}.", idMsgOriginale);

                // 1. Create the new reply message (M_Replier_New)
                // Author of this new reply is idUteReplier (current user)
                // It replies to mOther (idMsgOriginale), whose author is idUteAutOriginale
                newlySentOrUpdatedMessage = insertMsgAndTags(
                    idUteReplier,        // Author of this new reply
                    idUteAutOriginale,   // Recipient of this new reply
                    desMsgNoHtml,
                    ConstantsDefinition.CODMSG_PRI, // New reply is Private
                    idFoglio,            // Paper for this conversation
                    idMsgOriginale,      // This new message is a reply to mOther
                    false             
                );

                if (newlySentOrUpdatedMessage == null || newlySentOrUpdatedMessage.getIdMsg() == null) {
                    logger.error("******insertReplyMsg: Failed to create new reply message record for M_Other ID {}.", idMsgOriginale);
                    throw new Exception("Failed to create reply message record.");
                }

                // 2. Update the original message (mOther) to link to this new reply and become private (or LET)
                mOther.setIdUteReply(idUteReplier); // The user who just replied
                mOther.setIdMsgReply(newlySentOrUpdatedMessage.getIdMsg()); // Link to the new reply
                mOther.setCodTipMsg(ConstantsDefinition.CODMSG_LET); // Mark mOther as "read" by its author, as it now has a reply they need to see.
                                                                     // Or PRI if you want the author to "view" it to turn it to LET.
                                                                     // LET is more direct for turn-taking.
                mOther.setDatUltMov(Calendar.getInstance().getTime());
                messaggioService.save(mOther); // Save the updated original message

                logger.info("insertReplyMsg: First reply created (ID: {}). Original message (ID: {}) updated.", newlySentOrUpdatedMessage.getIdMsg(), idMsgOriginale);

            } 
            // Scenario 2: Subsequent reply in an existing private conversation (ping-pong update)
            else if (mOther.getIdMsgReply() != null && 
                     (ConstantsDefinition.CODMSG_PRI.equals(mOther.getCodTipMsg()) || ConstantsDefinition.CODMSG_LET.equals(mOther.getCodTipMsg())) ) {
                
                logger.debug("insertReplyMsg: Subsequent reply in private conversation. Replying to M_Other (ID: {}). M_Other's reply pointer: {}", idMsgOriginale, mOther.getIdMsgReply());

                // mOther is the message from the other user (e.g., User B's message)
                // mOther.getIdMsgReply() points to the current user's (User A's) message slot in this conversation (M_Current_Slot)
                
                Messaggio mCurrentSlot = messaggioService.findById(mOther.getIdMsgReply());
				
                if (mCurrentSlot == null) {
                    logger.error("******insertReplyMsg: Current user's message slot (ID: {}) not found for M_Other ID {}.", mOther.getIdMsgReply(), idMsgOriginale);
                    throw new Exception("Conversation state error: user's message slot not found.");
                }

                // Ensure current user is indeed the author of this slot they are about to update
                if (mCurrentSlot.getIdUteAut() == null || !mCurrentSlot.getIdUteAut().equals(idUteReplier)) {
                     logger.error("******insertReplyMsg: Current user {} is not the author of message slot ID {} they are trying to update.", idUteReplier, mCurrentSlot.getIdMsg());
                     throw new Exception("Conversation state error: user mismatch on message slot.");
                }

                // 1. Update the current user's message slot (mCurrentSlot) with the new reply content
                mCurrentSlot.setDesMsg(desMsgNoHtml);
                mCurrentSlot.setCodTipMsg(ConstantsDefinition.CODMSG_PRI); // Current user just sent this, so it's PRI
                mCurrentSlot.setDatUltMov(Calendar.getInstance().getTime());
                // idMsgReply, idUteAut, idUteReply on mCurrentSlot should remain pointing to mOther's details
                newlySentOrUpdatedMessage = messaggioService.save(mCurrentSlot); // Save updated M_Current_Slot
                
                if (newlySentOrUpdatedMessage == null) {
                     logger.error("******insertReplyMsg: Failed to update current user's message slot (ID: {}).", mCurrentSlot.getIdMsg());
                    throw new Exception("Failed to update user's message slot.");
                }

                // 2. Update the other user's message (mOther) to mark it as "read" (LET)
                //    and ensure its idMsgReply points to the (now updated) mCurrentSlot.
                mOther.setCodTipMsg(ConstantsDefinition.CODMSG_LET);
                mOther.setIdMsgReply(newlySentOrUpdatedMessage.getIdMsg()); // Link to the newly updated reply
                mOther.setIdUteReply(idUteReplier); // The user who just replied
                mOther.setDatUltMov(Calendar.getInstance().getTime()); // Also update its last movement
                messaggioService.save(mOther); // Save the updated M_Other

                logger.info("insertReplyMsg: Subsequent reply updated in M_Current_Slot (ID: {}). M_Other (ID: {}) updated to LET.", newlySentOrUpdatedMessage.getIdMsg(), idMsgOriginale);
                
                // Increment reply count statistic
                utenteActionCustomService.saveNumActionPerIdUteAndData(idUteReplier, ConstantsDefinition.COD_TIP_OPERAZ_REPLY, new Date());
            } else {
                logger.error("******insertReplyMsg: Cannot reply to message ID {} with current state (codTipMsg: {}, idMsgReply: {}).", idMsgOriginale, mOther.getCodTipMsg(), mOther.getIdMsgReply());
                return null; // Or throw specific exception
            }
            
            // Tags are usually not associated with private messages, but if they were,
            // one might clear them here as the conversation becomes private.
            // The original code did this for idMsgOriginale.
            messaggioTagCustomService.deleteTagsPerIdMsg(idMsgOriginale);
            if (newlySentOrUpdatedMessage != null && newlySentOrUpdatedMessage.getIdMsg() != null && 
                !newlySentOrUpdatedMessage.getIdMsg().equals(idMsgOriginale)) {
                messaggioTagCustomService.deleteTagsPerIdMsg(newlySentOrUpdatedMessage.getIdMsg());
            }
                                                                        
        } catch (Exception ex) {
            logger.error("******insertReplyMsg: General error processing reply to message ID {}: {}", idMsgOriginale, ex.getMessage(), ex);
            // Re-throw or handle as appropriate, potentially returning null or throwing a service-specific exception
            // For now, let it be caught by @Transactional for rollback
            if (ex instanceof RuntimeException) throw (RuntimeException)ex; // Avoid wrapping RuntimeExceptions
            throw new RuntimeException("Error processing reply: " + ex.getMessage(), ex);
        }   
        
        return newlySentOrUpdatedMessage; // Return the message that was just sent/updated by the current user
    }

	//conta numero messaggi di autori diversi e senza risposta
	public int countNumMessaggiAutDiversiPerTipoNoReply(Integer idUte, String codTipMsg) {
		
		int numMsg = 0;	
		try {			
			Integer intNumMsg = messaggioCustomJpaRepository.countNumMsgNotIdAutoreAndCodTipMsgAndReplyNull(idUte, codTipMsg);
			if ( null!=intNumMsg )
				numMsg = intNumMsg.intValue();
			
		} catch (Exception ex) {
			logger.error("******countNumMessaggiPerTipo: errore: " + ex.getMessage() );
		}		
		
		return numMsg;
	}

	
	//conta numero messaggi per autore
	public int countMsgByIdAutore(Integer idUteAut) {
		
		int numMsg = 0;	
		try {			
			Long intNumMsg = messaggioCustomJpaRepository.countMsgByIdAutore(idUteAut);
			if ( null!=intNumMsg )
				numMsg = intNumMsg.intValue();
			
		} catch (Exception ex) {
			logger.error("******countMsgByIdAutore: errore: " + ex.getMessage() );
		}		
		
		return numMsg;
	}
	
	//strappo messaggio
	@Override
	public boolean strappoMsg(Integer idUte, Integer idMsg, Integer idMsgReply) {
		boolean isError = false;
		try {

			//cancella eventuale risposta e relativi tags
			if ( null!=idMsgReply ) {
				//cancella tags /messaggio segnalato / messaggio originale
				deleteMsgTransaction(idMsgReply);
				
				//incrementa numero di strappi giornalieri solo per CONVERSAZIONE
				utenteActionCustomService.saveNumActionPerIdUteAndData(idUte, ConstantsDefinition.COD_TIP_OPERAZ_STRAPPA, new Date());			
			}

			//cancella tags /messaggio segnalato / messaggio originale
			deleteMsgTransaction(idMsg);			
		
		} catch (Exception ex) {
			logger.error("******strappoMsg: errore: " + ex.getMessage() );
			isError = true;
		}	
		return isError;
	}
	
	
	
	private void deleteMsgTransaction(Integer idMsg) {
		//cancella tags messaggio originale
		messaggioTagCustomService.deleteTagsPerIdMsg(idMsg);
		
		//cancella messaggio segnalato
		messaggioSegnalatoCustomService.deleteMsgPerIdMsg(idMsg);

		//cancella messaggio
		messaggioService.delete(idMsg);
	}

	//aggiornamento codice tipo messaggio e lettura messaggio REPLY
	@Override
	public Messaggio updateCodTipMsgAndFindMsgReply(Integer idMsg, String codTipMsg) {
				
		Messaggio msgOut = null;
		try {
			
			//load messaggio
			Messaggio messaggio = messaggioService.findById(idMsg);
			if ( null==messaggio )
				return msgOut;
						
			//aggiornamento messaggio LETTO			
			messaggio.setCodTipMsg(codTipMsg);
			messaggio.setDatUltMov( Calendar.getInstance().getTime() );												
			MessaggioEntity messaggioEntity = new MessaggioEntity();
			messaggioServiceMapper.mapMessaggioToMessaggioEntity(messaggio, messaggioEntity);
			MessaggioEntity	messaggioEntitySaved = messaggioJpaRepository.save(messaggioEntity);
			
			msgOut = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntitySaved);			                      					
		} catch (Exception ex) {
			logger.error("******updateCodTipMsgAndFindMsgReply: errore: " + ex.getMessage() );			
		}	
		
		return msgOut;
	}
	
	//lettura messaggio per idMsg e foglio
	public Messaggio findMsgByIdMsgAndIdFoglio(Integer idMsg, Integer idFoglio) {
		
		Messaggio messaggio = null;	
		try {			
			MessaggioEntity msgEnt = messaggioCustomJpaRepository.findByIdMsgAndIdFoglio(idMsg, idFoglio);	
			if ( null==msgEnt )
				return messaggio;
			
			//conversione
			messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(msgEnt);
			
		} catch (Exception ex) {
			logger.error("******findMsgByIdMsgAndIdFoglio: errore: " + ex.getMessage() );
		}		
		
		return messaggio;
	}

	//conta numero di fogli utilizzati dall'utente
	public int countNumFogliUtilizzati(Integer idUte) {
		
		int numFogli = 0;	
		try {			
			Integer intNumFogli = messaggioCustomJpaRepository.countNumFogliUtilizzati(idUte);
			if ( null!=intNumFogli )
				numFogli = intNumFogli.intValue();
			
		} catch (Exception ex) {
			logger.error("******countNumFogliUtilizzati: errore: " + ex.getMessage() );
		}		
		
		return numFogli;
	}
	
	//lettura di tutti i messaggi per autore 	
	public List<Messaggio> findMsgByAutore(Integer idUteAut) {
		
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByIdAutore(idUteAut);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				
				//check se messaggio presenta risposta
				boolean	isPresenteRisposta = false;
			  
				//per messaggio privato, lettura messaggio originale
				String codTipMsg = messaggio.getCodTipMsg();		
				if ( null!=codTipMsg && codTipMsg.equals(ConstantsDefinition.CODMSG_PRI )) {
					
					//lettura risposta PRIVATA
					Messaggio msgRisposta = findMsgPerConversazionePrivata(messaggio.getIdMsgReply()
																		 , messaggio.getIdUteReply()
																		 , messaggio.getIdUteAut()																						 
																		 , messaggio.getIdMsg());					
					//se risposta successiva a messaggio originale NO REPLY			
					if ( null!=msgRisposta && msgRisposta.getDatUltMov().compareTo(messaggio.getDatUltMov())>0 )	{						
						isPresenteRisposta = true;					
					}			

				}//endif codTipMsg									
				
				messaggio.setPresenteRisposta(isPresenteRisposta);
				
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgByAutore: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}

	public List<AggregateMsgPerCatEntity> countNumMsgPerTipo() {

		List<AggregateMsgPerCatEntity> listMsgPerTipo = null;	
		try {			
			listMsgPerTipo = messaggioCustomJpaRepository.countNumMsgPerTipo();
			
		} catch (Exception ex) {
			logger.error("******countNumMsgPerTipo: errore: " + ex.getMessage() );
		}		
		
		return listMsgPerTipo;
	}
	
	//ricerca dei messaggi per hashtag e diversi da autore corrente 	
	public List<Messaggio> findMsgPubByHashTagAndNotAutore(String hashtag, Integer idUteAut) {
		
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findMsgPubByHashTagAndNotAutore(hashtag, idUteAut);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgPubByHashTagAndNotAutore: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}
	
	//lettura messaggi per tipo messaggi
	public List<Messaggio> findMsgPerCodTipMsg(String codTipMsg) {
		List<Messaggio> listMsg = null;	
		try {			
			List<MessaggioEntity> listMsgEnt = messaggioCustomJpaRepository.findByCodTipMsg(codTipMsg);
			if ( null==listMsgEnt || listMsgEnt.isEmpty() )
				return listMsg;
			
			listMsg = new ArrayList<Messaggio>();
			for (MessaggioEntity messaggioEntity : listMsgEnt) {				
				
				if ( null==messaggioEntity )
					continue;
				
				Messaggio messaggio = messaggioServiceMapper.mapMessaggioEntityToMessaggio(messaggioEntity);
				listMsg.add(messaggio);
			}
			
		} catch (Exception ex) {
			logger.error("******findMsgPerCodTipMsg: errore: " + ex.getMessage() );
		}		
		
		return listMsg;
	}
	
	//conta numero di messaggi NUOVI pubblicati per DATA PUB
	public List<AggregateMsgPerDatPub> countMsgPerDataPubAfterDataInput(Date dataIn) {
		
		List<AggregateMsgPerDatPub> listNumMsg = null;	
		try {			
			listNumMsg = messaggioCustomJpaRepository.countMsgPerDataPubAfterDataInput(dataIn);
			
			
		} catch (Exception ex) {
			logger.error("******countMsgPerDataInput: errore: " + ex.getMessage() );
		}		
		
		return listNumMsg;
	}

}
